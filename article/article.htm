<!DOCTYPE HTML>
<!--------------------------------------------------------------------------->  
<!--                           INTRODUCTION                                

 The CodeProject article submission template (HTML version)

Using this template will help us post your article sooner. To use, just 
follow the 3 easy steps below:
 
     1. Fill in the article description details
     2. Add links to your images and downloads
     3. Include the main article text

That's all there is to it! All formatting will be done by our submission
scripts and style sheets. 

-->  
<!--------------------------------------------------------------------------->  
<!--                        IGNORE THIS SECTION                            -->
<html>
<head>
<title>CodeProject</title>
<Style>
BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
BODY {padding:15px; }
H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
H2 { font-size: 13pt; }
H3 { font-size: 12pt; }
H4 { font-size: 10pt; color: black; }
PRE { BACKGROUND-COLOR: #FBEDBB; FONT-FAMILY: "Courier New", Courier, mono; WHITE-SPACE: pre; }
CODE { COLOR: #990000; FONT-FAMILY: "Courier New", Courier, mono; }
</style>
<link type="text/css" rel="stylesheet" 
      href="https://codeproject.global.ssl.fastly.net/App_Themes/CodeProject/Css/Main.min.css">
</head>
<body bgcolor="#FFFFFF" color=#000000>
    <!--------------------------------------------------------------------------->
    <!-------------------------------     STEP 1      --------------------------->
    <!--  Fill in the details (CodeProject will reformat this section for you) -->

    <pre>
Title:       StringShear - A science project adventure in C# and C++
Description: A science program is rearranged and ported from C# to C++, with surprising results
Abstract:    You would think that C++ would run laps around C# for a science project,
             that taking the time to do things right in C++ would pay off big time.
             I explore the porting process and the performance measurement,
             and the startling conclusion.

Author:      Michael Sydney Balloni
Email:       balloni.michael@yahoo.com

Language:    C#, C++
Platform:    Windows
Technology:  .NET Framework, C++ Standard Library
Topic:       Scientific programming

Section      Not sure
SubSection   Not sure

License:     Apache 2.0
</pre>

    <!-------------------------------     STEP 2      --------------------------->
    <!--  Include download and sample image information.                       -->

    <ul class=download>
        <li><a href="Article_src.zip">Download source - XXX Kb</a></li>
    </ul>

    <!-------------------------------     STEP 3      --------------------------->
    <!--  Add the article text. Please use simple formatting (<h2>, <p> etc)   -->

    <h2>Introduction</h2>

    <p>
        A little background.
    </p>
    <p>
        I was a stellar math and physics student in high school.
        Let's say I peaked early...
    </p>
    <p>
        College math and physics was much harder than expected.
        I ended up meeting my wife and learning C++.
        Mission accomplished!
    </p>
    <p>
        FYI:
        When I entered college they taught new students C++.
        When I left they were teaching noobs Java.
        Now they teach them Python.
        Alas.
    </p>
    <p>
        So even though physics didn't work out in college,
        I still dreampt of crazy delusional things like nuclear fusion.
        I wanted to get on a team doing that sort of thing,
        to save the world from wars over fossil fuels.
        Yep, crazy and delusional.
    </p>

    <h2>Setting Off To Do Science</h2>
    <p>
        So I took a third semester physics class from the local community college.
        The coolest experiment was "Simple Harmonic Motion On A String."
        In this experiment, there's a string suspended above a table.
        At one end the string is held fixed with a weight applied, creating tension.
        At the other end of the table the string is passed over an oscillator,
        an uppy-downy thing that moves that end of the string up and down.
        The oscillator's motion can be dialed in to a specific frequency,
        and, then, magic: Patterns called standing waves appear on the vibrating string.
        With what are called resonant frequencies, the standing waves become pronounced, large patterns emerge.
        This fascinated the hell out of me.
        <br>
        <br>
        <b><a target=_blank href="https://www.google.com/search?q=standing+waves+on+a+string&source=lnms&tbm=isch&sa=X&ved=2ahUKEwjgi_uG1-jyAhX3HjQIHd8xCdoQ_AUoA3oECAEQBQ&cshid=1630874100764215&biw=1280&bih=577">Many great diagrams here</a></b>
    </p>
    <p>
        As a software guy, I was inspired to take a diagram from the textbook
        and try to make a simulation of the standing waves string experiment.
        At the time, Microsoft was not giving away the crown jewels for free the way they
        have done with Visual Studio 2017 and 2019 Community Editions.
        I wanted to do C++ programming, and the only way to do that back in the days of Visual Studio Express
        was .NET's C++/CLI, called Managed C++ at the time.  I hope you like carrots!
        It had a form designer, and the .NET library was quite workable.
        So I set to work.
    </p>
    <p>
        Months of development and tuning later, I had a working simulation.
        Tuning it took forever.
        There are a couple of hard-fought magic numbers I had to hone in on
        to get it to where you can put in a frequency like 20 Hz and see a standing wave.
    </p>

    <h2>The User Interface</h2>
    <img src=screen.png width=600>
    <br clear=all>
    <p>
        At the left, top to bottom, are a real-time view of the string,
        and snapshots of the string when it was at its most extreme
        amplitude (height), velocity (up and down), acceleration, and punch (not fruit, change in acceleration).
    </p>
    <p>
        At the right are the simulation controls.
        <ul>
            <li>
                <b>Time Slice</b> is how quickly the simulation runs, in parts of a millisecond.
                Too high and the simulation is not realistic.
                Too low and the simulation runs too slowly.
                Best to not go higher that 0.01.
                You might go lower to validate that something you observed
                is not some artifact of simulation overload.
            </li>
            <li>
                <b>Simulation Speed</b> controls the delay in the simulation's update loop.
                For any real study you would run it at All Out for hours on end.
                You can use lower speeds to observe the string motion in even slower motion.
            </li>
            <li>
                <b>Tension / Root Note</b> is tricky.
                The number you see there is a magic number arrived at tuning the string to resonate at 10 Hz.
                You can enter music notes, like C0, and then instead of frequencies you can enter other musical notes,
                and see how consonance and dissonance play out on the string.
                Mad science.
            </li>
            <li>
                <b>Oscillators</b> define the vibrations made at the ends of the strings.
                Not limited to a single physical oscillator with a single frequency,
                you can enter whatever you'd like for either side or both.
                Don't get carried away, though.
                With too many frequencies, especially high ones, you start to see un-string-like behavior.
                It's a difficult point, that to find anything interesting you have to go to lengths that might
                mean that what you're seeing isn't realistic.
                You can try lowering the Time Slice and running the simulation for longer to see if what you
                found is realistic.
            </li>
            <li>
                <b>Out of Phase</b> sets the offset in the left versus the right oscillators.
                If you put the same frequency on the left and right, and set this to zero,
                the string will just move up and down; no standing waves will form.
                In the real world, I was able to prove this out with a string between two oscillators.
                Only when I reverse wired them did a standing wave form.
            </li>
            <li>
                <b>Just Pulse</b> and <b>Just Half Pulse</b> let you see how a standing wave forms in the very beginning
                with just one wave front moving down the string and echoing back.
            </li>
            <li>
                <b>Run / Pause</b> controls the simulation, starting or pausing or restarting it.
            </li>
            <li>
                <b>Reset</b> turns the clock back to zero and resets all the strings.
            </li>
            <li>
                <b>Reset Maximums</b> resets just the maximum strings.
                This is useful after running a simulation for a little while,
                to eliminate the weird stuff that happens early in a simulation,
                to reproduce a legitimate finding of interest, if there were such things.
            </li>
            <li>
                <b>Copy Stats Header</b> puts the stats columns on the clipboard to paste into a spreadsheet program.
            </li>
            <li>
                <b>Copy Stats Values</b> puts the stats values on the clipboard to paste into a spreadsheet program.
            </li>
            <li>
                <b><a target=_blank href="https://www.stringshear.com">stringshear.com</a></b>
                has an online TypeScript version of this project that you can play with,
                no need to download or build anything,
                and some documentation similar to this.
            </li>
        </ul>
    </p>
    <p>
        You can tell you've got a strong standing wave when in the top-left panel, the black
        circles at either end of the string aren't moving up-and-down much, but the string is.
        That's the magic, the resonant frequencies,
        where the string resonates with the vibrations it's getting from its ends.
    </p>
    <p>
        Build it and plug in the frequencies you've got here, and watch how, in really slow motion,
        the string moves, and maximum strings are recorded.
        It's mesmerizing.
    </p>

    <p>
        The science is interesting, but this is not a scientific journal.
        Let's talk code.
    </p>

    <h2>Moving On To The Code</h2>
    <p>
        Here are the projects in the attached code ZIP:
    </p>
    <p>
        <ul>
            <li><b>original</b> - C# port of the truly original C++/CLI WinForms program (2007!)</li>
            <li><b>app</b> - C# WinForms UI client that runs the show</li>
            <li><b>sharpsvr</b> - C# HttpListener server that implements the simulation</li>
            <li><b>sharplib</b> - C# class library that implements the guts of sharpsvr, and has code shared with the app for serialization</li>
            <li><b>sharpsvr</b> - C++ server that reimplements the simulation, with a little /CLI just for HttpListener that's identical with sharpsvr</li>
        </ul>
    </p>
    <p>
        Here are the classes of interest,
        named and coded (mostly) the same in C# and C++ for easy comparison:
    </p>
    <p>
        <ul>
            <li><b>Simulation</b> - Runs the experiment, and does serialization and event handling with the app</li>
            <li><b>Stringy</b> - Well, I couldn't call it String!  Manages its serialization and updating</li>
            <li><b>Particle</b> - Our string effectively consists of 1,000 beads, but particles sound cooler than beads</li>
            <li><b>ScopeTiming</b> - Performance tracking</li>
        </ul>
    </p>

    <h2>Code Mechanics</h2>
    <p>
        In the original app, all the classes are in the one project.
        To do a performance comparison between C++ and C#
        - as I am prone to do! -
        I needed to run the simulators out of process, in a C# server and a C++ server.
        Okay, I didn't <b>need</b> to do it that way,
        but it's nice to be able to leave the simulation running
        without having the app working the graphics card for hours on end.
    </p>
    <p>
        So my plan of attack was to follow these steps,
        validating that things still worked at each step:
        <ol>
            <li>Pull non-UI bits out of the app into a class library, sharplib</li>
            <li>Introduce serialization of app commands and simulation state between the sharplib classes and the app UI</li>
            <li>Write a HttpListener server, sharpsvr, and use a WebClient in the app, and do out-of-process communication between the UI and the simulation</li>
            <li>Port the server and most of sharplib into a C++ server, seasvr</li>
        </ol>
        Let's dive in!
    </p>

    <h3>Performance Tracking with ScopeTiming - C#</h3>
    <pre>
using...
namespace...
/// <summary>
/// Utility class for timing sections of code
/// To do timing:
/// Call Init first to enable timing
/// Call StartTiming at the beginning of the code to time
/// Call RecordScope at the end of the code to time
/// Call Summary to get a summary of the timings performed
/// Call Clear to remove all timings
/// </summary>
public static class ScopeTiming
{
    /// <summary>
    /// Initialize to enable timing
    /// </summary>
    /// <param name="enable">Specify to enable timing</param>
    public static void Init(bool enable)
    {
        sm_enabled = enable;
    }

    /// <summary>
    /// Get a Stopwatch to start timing
    /// </summary>
    /// <returns>null if not enabled, or else a new Stopwatch</returns>
    public static Stopwatch StartTiming()
    {
        if (!sm_enabled)
            return null;

        return Stopwatch.StartNew();
    }

    /// <summary>
    /// Record the time since StartTiming was called
    /// </summary>
    /// <param name="scope">What area of the code would you call this?</param>
    /// <param name="sw">null if not timing, or Stopwatch started timing</param>
    public static void RecordScope(string scope, Stopwatch sw)
    {
        if (sw == null)
            return;

        lock (sm_timings)
        {
            Scope scopeObj;
            if (!sm_timings.TryGetValue(scope, out scopeObj))
            {
                scopeObj = new Scope() { ScopeName = scope };
                sm_timings.Add(scope, scopeObj);
            }

            ++scopeObj.Hits;
            scopeObj.Allotted += sw.Elapsed;
        }

        sw.Restart();
    }

    /// <summary>
    /// Get a summary of the recorded timings
    /// </summary>
    public static string Summary
    {
        get
        {
            var sb = new List<string>();
            lock (sm_timings)
            {
                foreach (Scope obj in sm_timings.Values)
                {
                    if (obj.Hits == 0)
                        continue;

                    sb.Add
                    (
                        $"{obj.ScopeName} -> {obj.Hits} hits - " +
                        $"{Math.Round(obj.Allotted.TotalMilliseconds)} ms total -> " +
                        $"{Math.Round(obj.Allotted.TotalMilliseconds / obj.Hits, 5)} ms avg"
                    );
                }
            }
            sb.Sort();
            return string.Join("\n", sb);
        }
    }

    /// <summary>
    /// Remove all timings
    /// </summary>
    public static void Clear()
    {
        lock (sm_timings)
            sm_timings.Clear();
    }

    private static bool sm_enabled;

    private class Scope
    {
        public string ScopeName;
        public int Hits;
        public TimeSpan Allotted;
    }
    private static Dictionary<string, Scope> sm_timings = new Dictionary<string, Scope>();
}
</pre>
    <h3>The Particle Class - C#</h3>
    <p>
        The Stringy class has an array of Particles,
        so they better be structs for good data locality.
        NOTE:
        ToString turns out to be wicked fast,
        but FromString does not have to be fast as it's app side, running at human time,
        so it's meant to be readable, not fast.
    </p>
    <pre>
// Define a particle as its x position along the string,
// its y position above or below the string,
// its velocity, its acceleration, and its punch (velocity of acceleration)
using System;
using System.Linq;

namespace StringShear
{
    public struct Particle
    {
        public double x;
        public double y;
        public double vel;
        public double acl;
        public double punch;
        public double nextNeighborFactor;

        // NOTE: Default constructor zeroes out all fields which is what we want

        public Particle(double _x, double _y = 0, double _vel = 0, double _acl = 0, double _punch = 0, double _next = 0)
        {
            x = _x;
            y = _y;
            vel = _vel;
            acl = _acl;
            punch = _punch;
            nextNeighborFactor = _next;
        }

        public override string ToString()
        {
            return $"{x},{y},{vel},{acl},{punch},{nextNeighborFactor}";
        }

        public static Particle FromString(string str)
        {
            double[] vals = 
                str
                .Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(x => double.Parse(x))
                .ToArray();
            if (vals.Length != 6)
                throw new Exception("Particle parsing fails: " + str);

            return new Particle(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);
        }

        public double GetVal(int index)
        {
            switch (index)
            {
                case 0: return x;
                case 1: return y;
                case 2: return vel;
                case 3: return acl;
                case 4: return punch;
                default: throw new Exception($"Invalid index to get: {index}");
            }
        }

        public void Reset()
        {
            // NOTE: Leave x position alone
            y = vel = acl = punch = nextNeighborFactor = 0.0;
        }

        // Update the y value for this, computing vel and acl and punch,
        // and returning the work performed (acl * distance)
        // This is used for endpoints of the string
        public double SetPosY(double newPosY, double elapsedTime, double time)
        {
            double newDisplacement = (newPosY - y);

            double newVel = newDisplacement / elapsedTime;

            double newAcl = (newVel - vel) / elapsedTime;
            if (time <= elapsedTime)
                newAcl = 0.0;

            double newPunch = (newAcl - acl) / elapsedTime;
            if (time <= elapsedTime * 2.0)
                newPunch = 0.0;

            double workDone = newDisplacement * acl;

            y = newPosY;
            vel = newVel;
            acl = newAcl;
            punch = newPunch;

            return Math.Abs(workDone);
        }
    }
}
</pre>

    <h3>The Particle Class - C++</h3>
    <p>
        Remarkably similar to the C# version.
        No string serialization to be found.
    </p>
<pre>
#pragma once

#include &lt;math.h&gt;
#include &lt;exception&gt;

namespace...
struct Particle
{
    double x;
    double y;
    double vel;
    double acl;
    double punch;
    double nextNeighborFactor;

    Particle()
    {
        memset(this, 0, sizeof(Particle));
    }

    Particle(double _x, double _y = 0, double _vel = 0, double _acl = 0, double _punch = 0, double _next = 0)
    {
        x = _x;
        y = _y;
        vel = _vel;
        acl = _acl;
        punch = _punch;
        nextNeighborFactor = _next;
    }

    double GetVal(unsigned index) const
    {
        switch (index)
        {
        case 0: return x;
        case 1: return y;
        case 2: return vel;
        case 3: return acl;
        case 4: return punch;
        default: throw std::exception("Particle::GetVal invalid index");
        }
    }

    void Reset()
    {
        // NOTE: Leave x position alone
        y = vel = acl = punch = nextNeighborFactor = 0.0;
    }

    // Update the y value for this, computing vel and acl and punch,
    // and returning the work performed (acl * distance)
    // This is used for endpoints of the string
    double SetPosY(double newPosY, double elapsedTime, double time)
    {
        double newDisplacement = (newPosY - y);

        double newVel = newDisplacement / elapsedTime;

        double newAcl = (newVel - vel) / elapsedTime;
        if (time <= elapsedTime)
            newAcl = 0.0;

        double newPunch = (newAcl - acl) / elapsedTime;
        if (time <= elapsedTime * 2.0)
            newPunch = 0.0;

        double workDone = newDisplacement * acl;

        y = newPosY;
        vel = newVel;
        acl = newAcl;
        punch = newPunch;

        return fabs(workDone);
    }
};
</pre>

    <h3>The String(y) Class - C#</h3>
    <pre>
// Define a string as a list of particles,
// and track the maximum position, velocity, acceleration, and punch of this,
// and the work done to move the end points, and the max work required to move the end points
...
namespace...

public class Stringy
{
    Particle[] m_particles;
    double m_length;

    // What were our most extreme values of Particles on this string?
    double m_maxPos;
    double m_maxVel;
    double m_maxAcl;
    double m_maxPunch;

    // Which particle had the most extreme value?
    int m_maxPosIndex;
    int m_maxVelIndex;
    int m_maxAclIndex;
    int m_maxPunchIndex;

    bool m_waveDownAndBackYet;

    Stopwatch m_sw = new Stopwatch();

    public Stringy(Particle[] particles, double length)
    {
        m_length = length;
        m_particles = (Particle[])particles.Clone();
    }

    public Stringy(int particleCount, double length)
    {
        m_length = length;

        // Initialize the particles, spreading them out across the length
        m_particles = new Particle[particleCount];
        m_particles[0] = new Particle();
        for (int i = 1; i < particleCount; ++i)
            m_particles[i] = new Particle(m_length * 1.0 * i / (particleCount - 1));
    }

    public override string ToString()
    {
        m_sw.Restart(); // we (re)use a Stopwatch for seeing what takes time
        StringBuilder sb = new StringBuilder();

        // Somehow this piece of Linq outperforms the C++ counterpart around 40% 1.7ms vs. 2.4ms
        sb.Append("particles:" + string.Join("|", m_particles.Select(p => p.ToString())) + ";");
        ScopeTiming.RecordScope("Stringy.ToString.Particles", m_sw);
        // ScopeTiming.RecordScope records how long the Stopwatch.Elapsed associated with the name "String.To..."
        // and does a Stopwatch.Restart()

        sb.Append("length:" + m_length + ";");

        sb.Append("maxPos:" + m_maxPos + ";");
        sb.Append("maxVel:" + m_maxVel + ";");
        sb.Append("maxAcl:" + m_maxAcl + ";");
        sb.Append("maxPunch:" + m_maxPunch + ";");
        ...
        ScopeTiming.RecordScope("Stringy.ToString.TheRest", m_sw); // no time

        string str = sb.ToString();
        ScopeTiming.RecordScope("Stringy.ToString.sb.ToString", m_sw);
        return str;
    }

    // App side code calls this to compute what the UI should show from the simulation's state
    public static Stringy FromString(string str)
    {
        var dict = new Dictionary&lt;string, string&gt;();
        foreach (string line in str.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries))
        {
            int colon = line.IndexOf(':');
            string name = line.Substring(0, colon);
            string value = line.Substring(colon + 1);
            dict.Add(name, value);
        }

        double length = double.Parse(dict["length"]);

        Particle[] particles = 
            dict["particles"]
            .Split(new[] { '|' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(s => Particle.FromString(s))
            .ToArray();

        Stringy stringy = new Stringy(particles, length);
            
        stringy.m_maxPos = double.Parse(dict["maxPos"]);
        stringy.m_maxVel = double.Parse(dict["maxVel"]);
        stringy.m_maxAcl = double.Parse(dict["maxAcl"]);
        stringy.m_maxPunch = double.Parse(dict["maxPunch"]);
        ...
        return stringy;
    }

    public Stringy Clone()
    {
        Stringy ret = new Stringy(m_particles, m_length);

        ret.m_maxPos = m_maxPos;
        ret.m_maxVel = m_maxVel;
        ret.m_maxAcl = m_maxAcl;
        ret.m_maxPunch = m_maxPunch;
        ...
        return ret;
    }

    // Update the particles of this given new endpoints, an elapsed time, and a tension
    // The tension defines how much acceleration the particles receive due to distance from
    // neighboring particles
    public
        void Update
        (
            double startPosY,
            double endPosY,
            double elapsedTime,
            double time,
            double tension,
            double damping,
            double stringLength,
            double stringConstant
        )
    {
        // Set the endpoints and add to the work we've performed for them
        // and track the max work we've seen for the endpoints.
        double newStartWork = m_particles[0].SetPosY(startPosY, elapsedTime, time);
        m_startWork += newStartWork;

        if (newStartWork > m_maxStartWork)
            m_maxStartWork = newStartWork;

        double newEndWork = m_particles[m_particles.Length - 1].SetPosY(endPosY, elapsedTime, time);
        m_endWork += newEndWork;

        if (newEndWork > m_maxEndWork)
            m_maxEndWork = newEndWork;

        //
        // Here's the magic from the textbook...
        //

        // Compute neighbor factors.
        for (int i = 0; i < m_particles.Length - 1; ++i)
        {
            double xGap = m_particles[i].x - m_particles[i + 1].x;
            double yGap = m_particles[i].y - m_particles[i + 1].y;
            double totalGap = Math.Sqrt(xGap * xGap + yGap * yGap);
            m_particles[i].nextNeighborFactor = Math.Abs((1.0 / totalGap) * yGap);
        }

        // Compute acceleration using neighbors.
        for (int i = 1; i < m_particles.Length - 1; ++i)
        {
            double prevComponent = m_particles[i - 1].nextNeighborFactor;
            if (m_particles[i - 1].y < m_particles[i].y)
                prevComponent = -prevComponent;

            double nextComponent = m_particles[i].nextNeighborFactor;
            if (m_particles[i + 1].y < m_particles[i].y)
                nextComponent = -nextComponent;

            double newAcl = tension * (prevComponent + nextComponent)
                            - damping * m_particles[i].vel;

            m_particles[i].punch = newAcl - m_particles[i].acl;

            m_particles[i].acl = newAcl;
        }

        // Update velocity and position.
        for (int i = 1; i < m_particles.Length - 1; ++i)
        {
            m_particles[i].vel += m_particles[i].acl * elapsedTime;
            m_particles[i].y += m_particles[i].vel * elapsedTime;
        }
        ...
    }
    ...
}
</pre>

    <h3>The String(y) Class - C++</h3>
    <p>
        The C++ code is line for line identical to the C# code, except...
        Serialization.  Our goal is to turn the string into, well, a std::string, as fast as possible.
        Here's my best effort, please propose something better.
        Having the sprintf_s inside the Particle class is not better.
        Passing around a stringstream is not better.
        We need something much better...and let's give it a try.
    </p>
    <pre>
void AppendToString(std::string& str) const
{
    m_sw.Start();

    str += "particles:";
    char buffer[4096];
    for (const auto& p : m_particles)
    {
        sprintf_s(buffer, sizeof(buffer), 
                    "%f,%f,%f,%f,%f,%f|",
                    p.x, p.y, p.vel, p.acl, p.punch, p.nextNeighborFactor);
        str += buffer;
    }
    str += ";";
    ScopeTiming::GetObj().RecordScope("String.AppendToString.Particles", m_sw);
    // This step here is about 40% slower than the Linq-based C# version...weird!

    str += "length:" + std::to_string(m_length) + ";";

    str += "maxPos:" + std::to_string(m_maxPos) + ";";
    str += "maxVel:" + std::to_string(m_maxVel) + ";";
    str += "maxAcl:" + std::to_string(m_maxAcl) + ";";
    str += "maxPunch:" + std::to_string(m_maxPunch) + ";";

    str += "maxPosIndex:" + std::to_string(m_maxPosIndex) + ";";
    str += "maxVelIndex:" + std::to_string(m_maxVelIndex) + ";";
    str += "maxAclIndex:" + std::to_string(m_maxAclIndex) + ";";
    str += "maxPunchIndex:" + std::to_string(m_maxPunchIndex) + ";";

    str += "startWork:" + std::to_string(m_startWork) + ";";
    str += "endWork:" + std::to_string(m_endWork) + ";";

    str += "maxStartWork:" + std::to_string(m_maxStartWork) + ";";
    str += "maxEndWork:" + std::to_string(m_maxEndWork) + ";";

    ScopeTiming::GetObj().RecordScope("String.AppendToString.TheRest", m_sw); // not much
}
</pre>

    <h3>The Simulation Class - C#</h3>
<pre>
...
public class Simulation
{
    public const int cParticleCount = 1000;
    public const double cStringConstant = 0.03164; // magic number
    public const double cStringLength = 1.0; // meter
    public const double cOscillatorAmplitude = 0.001; // mm
    ...
    public void Update()
    {
        // Delay.  Outside the thread safety lock.
        int delayMs = 0;
        {
            lock (this)
            {
                delayMs = m_delayMs;

                if (delayMs > 0)
                {
                    if (m_delayMod > 0)
                    {
                        if ((m_simulationCycle % m_delayMod) != 0)
                            delayMs = 0;
                    }
                }
            }
        }

        // Bail if we're paused, but sleep to keep the processor cool.
        if (m_bPaused)
        {
            Thread.Sleep(200);
            return;
        }

        // Yield to the main application thread to cool off the CPU...
        // ...unless we're running flat out!
        if (delayMs >= 0)
            Thread.Sleep(delayMs);

        lock (this)
        {
            m_computeStopwatch.Restart();

            ++m_simulationCycle;

            double startPos = 0.0;
            if (m_bLeftEnabled)
            {
                foreach (double frequency in m_leftFrequencies)
                {
                    startPos += GetOscillatorPosition(frequency,
                                                        cOscillatorAmplitude,
                                                        m_bJustPulse,
                                                        m_bJustHalfPulse,
                                                        m_outOfPhase,
                                                        m_time);
                }
            }

            double endPos = 0.0;
            if (m_bRightEnabled)
            {
                foreach (double frequency in m_rightFrequencies)
                {
                    endPos += GetOscillatorPosition(frequency,
                                                    cOscillatorAmplitude,
                                                    m_bJustPulse,
                                                    m_bJustHalfPulse,
                                                    /* outOfPhase = */0.0,
                                                    m_time);
                }
            }

            m_string.Update
            (
                startPos,
                endPos,
                m_timeSlice,
                m_time,
                m_tension,
                m_damping,
                cStringLength,
                cStringConstant
            );

            if (Math.Abs(m_string.GetMaxPos()) > Math.Abs(m_maxPosString.GetMaxPos()))
            {
                m_maxPosString = m_string.Clone();
                m_maxPosTime = m_time;
            }

            if (Math.Abs(m_string.GetMaxVel()) > Math.Abs(m_maxVelString.GetMaxVel()))
            {
                m_maxVelString = m_string.Clone();
                m_maxVelTime = m_time;
            }

            if (Math.Abs(m_string.GetMaxAcl()) > Math.Abs(m_maxAclString.GetMaxAcl()))
            {
                m_maxAclString = m_string.Clone();
                m_maxAclTime = m_time;
            }

            if (Math.Abs(m_string.GetMaxPunch()) > Math.Abs(m_maxPunchString.GetMaxPunch()))
            {
                m_maxPunchString = m_string.Clone();
                m_maxPunchTime = m_time;
            }

            m_time += m_timeSlice;
            ScopeTiming.RecordScope("Update", m_computeStopwatch);
        }
    }

    // Get the position of this at a particular time
    public static double // static to ensure purity of processing
        GetOscillatorPosition
        (
            double frequency,
            double amplitude,
            bool bJustPulse,
            bool bJustHalfPulse,
            double outOfPhase,
            double time
        )
    {
        double radians = 2.0 * Math.PI * frequency * time;

        radians -= outOfPhase * Math.PI;

        if (radians < 0.0)
            radians = 0.0;

        if (bJustPulse && radians > 2.0 * Math.PI)
            radians = 0.0;
        else if (bJustHalfPulse && radians > 1.0 * Math.PI)
            radians = 0.0;

        double retVal = Math.Sin(radians);

        retVal *= amplitude;

        return retVal;
    }
}
</pre>
    <p>
        The Update function should be faster in C++, right?
        Better C math routines?  Better array processing?  Right?!?!
        Nope, just about the same, even a smidge faster in C#.
        What the...
    </p>

    <h3>Performance Profile - C#</h3>
<pre>
Output.StreamWriter -> 281 hits - 1898 ms total -> 6.75605 ms avg
Output.ToString -> 281 hits - 3145 ms total -> 11.191 ms avg
Stringy.ToString.Particles -> 1405 hits - 2532 ms total -> 1.8023 ms avg
Stringy.ToString.sb.ToString -> 1405 hits - 57 ms total -> 0.04033 ms avg
Stringy.ToString.TheRest -> 1405 hits - 8 ms total -> 0.00565 ms avg
Update -> 1018186 hits - 25371 ms total -> 0.02492 ms avg
</pre>

    <h3>Performance Profile - C++</h3>
    <pre>
Output.StreamWriter -> 252 hits - 1188.165000 ms total -> 4.714940 ms avg
Output.ToString -> 252 hits - 7726.400000 ms total -> 30.660317 ms avg
String.ToString.Particles -> 1260 hits - 3150.636000 ms total -> 2.500505 ms avg
String.ToString.TheRest -> 1260 hits - 16.469000 ms total -> 0.013071 ms avg
Update -> 709880 hits - 21241.036000 ms total -> 0.029922 ms avg
</pre>

    <h3>Performance Comparison</h3>
    <p>
        You can see that sending strings from the servers to the app, the Output steps,
        are quite different, 30 C++ vs. 11 C# for ToString (wow!), and 4.7 vs. 6.7 for StreamWriter (strange!).
        Why is computing the string so much slower for C++?
        And why is the StreamWriter step slower for C#?  That .NET code should be near identical.
    </p>
    <p>
        Looking into the String.ToString, the big difference is how the particles are added to the string.
        Which is baffling how C#'s $"{x}..." is faster than C++'s sprintf_s.  A lot faster.  Riddle me that one!
    </p>
    <p>
        And the Update step is near identical between C++ and C#.  C# is even a little faster.
        The implementations are line-for-line identical, this one makes no sense.
    </p>

    <h2>Conclusion and Points of Interest</h2>
    <p>
        This has been a great game of software development, tuning, measurement, and optimization.
        The results are remarkable: there's no benefit to using C++ vs. C# for this application.
        C#'s $ string builder outruns C++'s sprintf_s.
    </p>
    <p>
        Back to mad science...
    </p>
    <p>
        If you're game, try picking some frequencies and shear the string, cause a particle to fly off,
        see something interesting, and share what you found.
    </p>
    <p>
        Or have at the code, explore performance profiles by adding more timing, try speeding things up.
    </p>

    <!-------------------------------    That's it!   --------------------------->
</body>

</html>

